import re, os, pprint, time, textwrap

template_header = """# Copyright (C) {year} Infineon Technologies AG
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# This file was automatically generated by {self}, do not alter this file.

\"\"\"
Definition of exceptions.
\"\"\"

class GeneralError(Exception):
    def __init__(self, error_code : int, error_description : str):
        '''Create new RadarSDKException with error code given by error'''
        self.error_code = error_code
        self.error_description = error_description

    def __repr__(self):
        '''Exception message'''
        return self.error_description

"""

# Template for an error class (like ErrorNoDevice for IFX_ERROR_NO_DEVICE)
template_class = """class {exception_name}({exception_parent}):
    '''{error_description}
    '''
    def __init__(self, error_description):
        super().__init__(0x{error_code:X}, error_description)
"""

# Template for categories (like ErrorDevBase for IFX_ERROR_DEV_BASE)
template_class_parent = """class {exception_name}({exception_parent}):
    '''{error_description}'''
    pass
"""

# Template for error mapping (code to exception)
template_error_mapping = """
error_mapping_exception = {{
{error_mapping}
}}


def get_exception(error_code : int, error_description : str ="Unknown error"):
    try:
        return error_mapping_exception[error_code](error_description)
    except:
        return GeneralError(error_code, error_description)


"""


def read_file(filename : str) -> str:
    """Read the file given by filename.

    The function returns the content of the file as a single string with
    comments starting with // removed.
    """
    with open(filename, "r") as f:
        lines = []
        for line in f:
            p = line.find("//")
            if p >= 0:
                lines.append(line[:p])
            else:
                lines.append(line)

    return "\n".join(lines)

def remove_whitespace(s : str) -> str:
    """Remove whitespace from string

    The function returns a string of s with multiple whitespace replaced by a
    single space.
    """
    return ' '.join(s.split())

def eval_error_code_str(error_code_str : str) -> int:
    """Parse string of the form
        0x00010000 + 0x15
    and return the resulting integer
    """
    def hexstr_to_int(s : str) -> int:
        s = s.strip()
        if not s.startswith("0x"):
            raise ValueError("Not a hexadecimal number")
        return int(s[2:], 16)

    return sum(map(hexstr_to_int, error_code_str.split("+")))

def text_to_docstring(text : str) -> str:
    """Convert text to a docstring (including 4 spaces of indentation)"""
    return"\n    ".join(textwrap.wrap(text))

def c_to_python_name(c_name : str) -> str:
    """Convert a C name to the specific python name.

    For instance, IFX_ERROR_NO_DEVICE will be translated to ErrorNoDevice.
    """
    return c_name.replace("IFX_", "").title().replace("_", "")

def parse_error_enum(filename : str) -> list:
    """Parse enum ifx_Error_e
    
    Parse the enum ifx_Error_e and return for each error code the exception
    name, the error code, and the error description.
    
    Parameter:
        filename: path to Error.h file
    
    Returns:
        error categories: list of error categories
        errors: list of errors

        each is list contains tuples with exception name, error code, parent exception, error description
    """
    content = read_file(filename)

    matches = re.findall("#define (IFX_ERROR_.+?_BASE)\s+(0x\d+)", content)
    error_base = { name: code for (name, code) in matches }

    # Create classes for base exceptions XXX
    error_categories = []
    for (error_name, error_code) in error_base.items():
        exception_name = c_to_python_name(error_name)
        exception_parent = "GeneralError"
        error_description = f"Error class for {exception_name}"
        error_categories.append((int(error_code, 16), exception_name, exception_parent, error_description))

    enum_start = content.find("enum ifx_Error_e")
    start = content.find("{", enum_start)
    stop = content.find("}", start)

    enum = content[start:stop].replace("\n", " ")

    matches = re.findall(r"(IFX_ERROR.*?)\s*=\s*(.+?),?\s*/\*\*<\s*(.+?)\s*\*/", enum)

    error_list = []
    for (error_name, error_code_str, error_description) in matches:
        exception_parent = error_code_str.split()[0]
        for key, value in error_base.items():
            error_code_str = error_code_str.replace(key, value)

        error_description = remove_whitespace(error_description)
        error_description = error_description.replace(r"\ref", "")
        error_description += f" ({error_name})"

        exception_parent = c_to_python_name(exception_parent)
        exception_name = c_to_python_name(error_name)
        error_code = eval_error_code_str(error_code_str)

        error_list.append((error_code, exception_name, exception_parent, error_description))

    return error_categories, error_list

def generate_error_script(filename: str) -> str:
    """Generate ifxError.py from Error.h
    
    Parameter:
        filename: path to Error.h
    
    Returns:
        Content of ifxError.py as string
    """
    error_categories, error_list = parse_error_enum(filename)
    error_mapping = ["    {}: {},".format(code, name) for (code, name, _, _) in error_list]
    error_mapping = "\n".join(error_mapping)

    fillins = {
        "self": os.path.basename(__file__),
        "year": time.strftime("%Y"),
    }

    script = template_header.format(**fillins)

    for (code, exception_name, exception_parent, description) in error_categories:
        docstring = text_to_docstring(description)

        fillins = {
            "error_code": code,
            "exception_name": exception_name,
            "exception_parent": exception_parent,
            "error_description": docstring
        }
        script += template_class_parent.format(**fillins) + "\n"

    for (code, exception_name, exception_parent, description) in error_list:
        docstring = text_to_docstring(description)

        fillins = {
            "error_code": code,
            "exception_name": exception_name,
            "exception_parent": exception_parent,
            "error_description": docstring
        }
        script += template_class.format(**fillins) + "\n"

    fillins = {
        "error_mapping": error_mapping
    }
    script += template_error_mapping.format(**fillins) + "\n"

    return script.rstrip()

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Create ifxError.py from Error.h file")
    parser.add_argument("-i", "--input", type=str, action="store", help="path to Error.h")
    parser.add_argument("-o", "--output", type=str, action="append", help="output filename")
    args = parser.parse_args()
    
    script = generate_error_script(args.input)
    
    if args.output is None:
        # no output filename given, print to stdout
        print(script)
        exit(0)
    
    for filename in args.output:
        with open(filename, "w") as f:
            print(script, file=f)
